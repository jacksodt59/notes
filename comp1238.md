## Week 1
## Lecture 1 - Historic Introduction about Text and Writing

*   **Course Context:** This course aims to cover fundamental tools for software developers that are often assumed knowledge but are frequently missed, such as keyboard proficiency, text editors, command line, and basic data handling. The initial focus is heavily on text because large part of our daily work deals with textual data.

## Text and Numbers Throughout History

*   **Motivation:** Understanding the history of a concept helps in understanding its current form (Aristotle quote). Computers often add complexity; looking at pre-computer history can simplify understanding. Many modern computing terms have historical roots.

*   **Origins of Writing:**
    *   Early markings: Cave paintings (France, 30,000 years ago) - possibly related to seasons/animals, but not writing.
    *   Counting: Ishango bone (Africa, 20,000 years ago) - definite tally marks, potentially for accounting/tracking.
    *   Early structures: Göbekli Tepe (Turkey, 10,000 years ago) - sophisticated structures with carvings, but no evidence of writing.
    *   First known writing: Appears around 5,000 years ago (3,000 BC). Earliest examples are clay tablets from Mesopotamia.

*   **Mesopotamia and Cuneiform:**
    *   Location: Fertile Crescent, between Tigris and Euphrates rivers (modern-day Iraq). Site of early civilizations.
    *   Earliest Tablets: Found in cities like Uruk/Ur. Often simple receipts (e.g., for barley and beer).
    *   Cuneiform: Means "wedge-shaped" in Latin. Named for the marks made by pressing a stylus into clay.
    *   Process: Started with drawing lines, evolved to pressing simple square/reed styluses into clay, which was faster and easier.
    *   [Show video of cuneiform writing]

*   **Babylonian Number System:**
    *   Symbols: A vertical wedge for '1', a horizontal wedge for '10'. Numbers 1-59 were formed by combining these (additive system).
    *   Example: Receipt likely showed numbers like 32 (three 10s and two 1s).
    *   Base-60 System (Sexagesimal): After 59, they used a positional system similar to ours, but with a base of 60. E.g., a symbol in the "sixties place" meant that value times 60.
    *   Significance: Allowed expression of very large numbers, important for accounting and mathematics.
    *   Terminology: Least significant digit (rightmost, represents units), Most significant digit (leftmost, represents largest place value).
    *   Why Base-60? Theory: Based on counting using fingers and knuckles. One hand counts to 12 (bones in fingers excluding thumb), the other hand keeps track of how many 12s (up to 5 fingers). 12 * 5 = 60.
    *   Legacy: We still use base-60 for time (minutes, seconds) and angles (degrees in a circle).

*   **Other Ancient Number Systems:**
    *   Egyptian Numerals: Had unique symbols for powers of 10 (1, 10, 100, 1000, etc.). Additive system. Example shown on a temple carving (~1.3 million).
    *   Roman Numerals: Symbols (I, V, X, L, C, D, M). Mostly additive, but with subtractive principle (IV=4, IX=9). Example shown on the Coliseum entrance (LII = 52). Messier for arithmetic compared to Babylonian or our system.

*   **Writing Systems vs. Language:**
    *   Early Literature: Epic of Gilgamesh (~4000 years ago, 2000 BC) - one of the earliest known long-form literary works. Story of a king's quest for immortality after his friend's death, includes a flood myth prototype. Shows the human desire to achieve immortality through writing stories.
    *   Behistun Inscription (Iran): Stone carving commissioned by King Xerxes the Great (Persian Empire, ~450 BC). Same text written in three different languages (Old Persian, Elamite, Babylonian) using variations of cuneiform script.
    *   Key Point: A writing system (like cuneiform or the Latin alphabet) can be used to write multiple different languages.

*   **Evolution of Alphabets:**
    *   Most European, Middle Eastern, and African alphabets trace back to Egyptian scripts, evolving through Proto-Sinaitic and the Phoenician alphabet.
    *   Phoenician alphabet gave rise to Greek, which led to Latin and Cyrillic.
    *   Aramaic alphabet (also from Phoenician) led to Arabic, Hebrew, and Syriac.
    *   Independent developments: Chinese script, Mesoamerican scripts (Inca, Mayan - later), Hangul (Korean, 15th century), Canadian Aboriginal syllabics (19th century).

*   **Decline of Cuneiform:** Despite clay tablets being durable, the cuneiform system was eventually abandoned and forgotten as more convenient writing surfaces (parchment, paper) and simpler alphabetic systems became widespread. Knowledge of texts like Gilgamesh was lost until rediscovery and deciphering in modern times.

## Printing History

*   **Early Printing:**
    *   Cylinder Seals: Used in Mesopotamia as early as 4,500 years ago (2600 BC). Rolled onto clay to leave a repeated impression (like a stamp). Example: Queen Puabi's seal.
    *   Woodblock Printing: Carving a whole page/image onto a wooden block, inking it, and pressing onto paper. Oldest known dated example: Diamond Sutra (China, 868 AD). Famous example: The Great Wave off Kanagawa (Japan, 1830s).
    *   Limitation: Difficult to correct errors or change text; required carving a new block for each variation.

*   **Movable Type:**
    *   Concept: Individual characters carved on small blocks that can be arranged and rearranged to form text.
    *   Origins: Developed in China around 1000 years ago (Song dynasty), using wood, clay, or metal.
    *   Advantage: Allows for easy correction and reuse of characters.

*   **Gutenberg and the Printing Press:**
    *   Johannes Gutenberg (Germany, ~1450s): Often credited with inventing printing, but more accurately, he perfected and popularized the movable type printing press in Europe. His success was significantly driven by business and economic factors.
    *   Background: Trained as a jeweler/goldsmith, giving him skills in working with metals and precision.
    *   Process: Developed a method for mass-producing metal types (alloy of lead, antimony, tin). Used a steel punch to create a copper matrix, then poured molten metal into a mold using the matrix. Finding the right alloy was crucial.
    *   Culmination: The Gutenberg Bible (1450s). A commercial enterprise aiming to produce Bibles cheaper than handwritten ones, though still a luxury product (180 copies printed, ~49 survive).

*   **Impact of the Printing Press:**
    *   Economic: Price of books collapsed over time, making them accessible beyond the very wealthy or institutions. [Show graph of book price history].
    *   Social/Cultural: Enabled mass distribution of information. Contributed significantly to the Protestant Reformation and the Renaissance by facilitating the spread of ideas. Within 50 years, thousands of print shops existed across Europe.

*   **Printing Terminology (Still Used Today):**
    *   Type: An individual block with a character on it.
    *   Typeface: The design or style of the letters (the "face" of the type). What we now often call a font family.
    *   Font: Historically, a complete set of types of a specific typeface, size, and style (e.g., 12-point Garamond Italic). Now often used interchangeably with typeface.
    *   Font Weight: Refers to the thickness of the strokes (bold, regular, light).
    *   Case: Uppercase (capital letters) and Lowercase (small letters). Originated from printers storing capital letters in cases on the upper shelf and small letters in cases on the lower shelf.
    *   Serif vs. Sans Serif: Serif fonts have small decorative strokes (serifs) at the end of letter strokes (like Times New Roman). Sans serif fonts ("sans" means "without" in French) do not (like Arial).
    *   Typesetting: The process of arranging type to create a page of text. Modern typesetting software (like Adobe InDesign) continues this tradition.

## Typewriters

*   **Invention:** Appeared in the 19th century (~150 years ago).
*   **Why Invented?** Not primarily for speed initially. Likely motivated by the need for standardized, legible text in business communication, as handwriting could be difficult to read and required educated readers. Typewritten text resembled printed text, improving clarity for a wider workforce.

*   **Terminology from Typewriters:**
    *   Carriage: The part of the typewriter that holds the paper and moves horizontally as you type.
    *   Carriage Return: The action of moving the carriage back to the left margin after finishing a line, and advancing the paper down one line. This is why the Enter key is often called "Return" and its symbol often shows an arrow going down and left.
    *   Margins/Ruler: Typewriters often had adjustable stops or rulers to set the left and right margins. Similar visual rulers exist in modern word processors.
    *   Monospace Fonts: Typewriters typically used fonts where every character occupies the same horizontal width (e.g., 'i' is as wide as 'o'). This was mechanically simpler to implement.
    *   Legacy: Monospace fonts are still predominantly used for writing code today for readability and alignment.
 
## Week 2
## Lecture 2 - Representing Text and Numbers in Computers

## Introduction
*   Today's topic: How computers store information (text, numbers) in memory.
*   Distinction between short-term (volatile) and long-term (persistent) memory.

## Computer Memory - Why Binary?
*   Many engineering systems find it simpler to communicate or store one of two states.
*   **Historical Example: Morse Code**
    *   Used short and long beeps/flashes.
    *   Invented in the 1840s by Samuel Morse (who was also a painter).
    *   System is still in limited use today.
    *   Demonstrates representing information (letters, digits) using only two distinct signals (short/long).
*   This concept of two states evolved into the **bit**.

## Bits and Bytes
*   **Bit:** Stands for **binary digit**. Represents one of two states (on/off, 0/1, true/false, short/long). The specific physical representation may vary:
    *   *Example:* Light signals - short flash vs. long flash (off isn't a signal in the dark).
    *   *Example:* CD-ROM surface - etched vs. not etched areas.
*   A single bit is very limited. Information is conveyed by grouping bits.
*   **Byte:** A standard group of 8 bits.
    *   Historically, experiments used 6 or 9 bits, but 8 bits became the universal standard. No deep technical reason, just convention.

## Historical Examples of Binary Storage
*   **Punched Cards:**
    *   Idea predates computers (18th century for textile machinery).
    *   Used holes (one state) vs. no holes (other state).
    *   Early computer cards had rows (~8) and columns (~80). Each column could represent a byte (8 bits). A card held about 80 bytes.
*   **Magnetic Core Memory:**
    *   Small rings of magnetic material. Magnetized in one direction or another to represent a bit.
    *   Example shown: 8x8 grid = 64 bits = 8 bytes.
    *   Contrast with modern storage: An 8GB SD card holds a billion times more data than the 8-byte core memory example. Technology advanced significantly.

## Volatile vs. Non-Volatile Memory
*   Most computer systems have two main types of memory based on purpose:
    *   **Short-term Memory:** Used for immediate tasks, currently running programs.
        *   Type: **Volatile** - data is lost when power is off.
        *   Example: **RAM** (Random Access Memory). Optimized for speed and high throughput. Accessing any byte is equally fast ("random access").
    *   **Persistent Long-term Memory:** Used for storing data permanently.
        *   Type: **Non-Volatile** - data persists without power.
        *   Examples: SD cards, Hard Disk Drives (HDDs), Solid State Drives (SSDs). Optimized for capacity and cost. Access speed can vary (e.g., slower on magnetic tape which needs rewinding).
*   **Physical Appearance:**
    *   RAM: Chips on a board (often a stick for laptops/desktops).
    *   Storage: HDDs (spinning magnetic platters, read/write arm - note latency from seeking/rotation), SSDs (based on semiconductor chips, faster than HDDs but slower than RAM, smaller connectors).
    *   **SSD (Solid State Drive):** Named after "solid state physics" which deals with semiconductors.
*   **Common Confusion:** People often mix up RAM and storage when discussing device specs (e.g., phone memory - usually refers to storage, but phones also have RAM). *Ask students for phone memory specs and clarify RAM vs. Storage.*

## Units of Measurement
*   Standard metric prefixes based on powers of 10:
    *   Kilo (k): 10^3 (1,000)
    *   Mega (M): 10^6 (1,000,000)
    *   Giga (G): 10^9 (1,000,000,000)
    *   Tera (T): 10^12 (1,000,000,000,000)
    *   *Ask for examples of "Mega" units outside computers (megajoules, megaparsec, megawatt).*
*   Powers of 2 are also important in computing:
    *   2^8 = 256 (important for bytes)
    *   2^10 = 1024 (close to 1000)
*   **The 1000 vs. 1024 Confusion:**
    *   Historically, people debated whether to use 1000 or 1024 for kilo/mega/giga prefixes when measuring bytes.
    *   Both definitions exist!
        *   Kilobyte (KB): 1000 bytes (based on powers of 10, used by storage manufacturers)
        *   Kilobyte (KB or KiB): 1024 bytes (based on powers of 2, often used in OS/software)
    *   The difference (2.5% for KB) grows significantly for larger units (almost 10% for TB).
    *   There's a convention to use **kibibyte (KiB)**, **mebibyte (MiB)**, etc., for 1024-based units, but it's not widely adopted.
    *   In most cases, the difference doesn't matter, but be aware for precise calculations.
*   **Megabits vs. Megabytes:**
    *   1 Byte = 8 bits.
    *   1 MB = 8 Megabits.
    *   Network speeds are often measured in megabits per second (Mbps) due to historical reasons from early communication standards.

## Representing Numbers
*   Humans decide how to interpret the bits.
*   Engineering convenience led to using the **binary number system** (base 2) to represent numbers directly with bits.
*   **Binary System Basics:**
    *   Uses only two digits: 0 and 1.
    *   **Positional System:** The value of a digit depends on its position.
    *   **Least Significant Bit (LSB):** The rightmost bit (represents 2^0 = 1).
    *   **Most Significant Bit (MSB):** The leftmost bit (represents the highest power of 2).
    *   **Conversion (Binary to Decimal):**
        *   Assign powers of 2 to each bit position, starting from 2^0 on the right (1, 2, 4, 8, 16, 32, 64, 128 for an 8-bit byte).
        *   Sum the powers of 2 where the bit is 1.
        *   *Example (from transcript):* `01010101` (8 bits)
            *   0*128 + 1*64 + 0*32 + 1*16 + 0*8 + 1*4 + 0*2 + 1*1 = 64 + 16 + 4 + 1 = **85** (decimal).
    *   Largest number in 8 bits: All bits are 1 (`11111111`). Sum of 1, 2, 4, ... 128 = **255**. (2^8 - 1).
    *   Largest number in 16 bits (2 bytes): 2^16 - 1 = **65535**.

## Signed vs. Unsigned Numbers
*   When interpreting a chunk of memory as a number, we must know if it's **signed** (can be positive or negative) or **unsigned** (only non-negative).
*   **Unsigned:** All bits contribute to the magnitude (0 to 255 for 1 byte).
*   **Signed:** One bit (MSB) is used to indicate the sign. Modern computers use **two's complement**.
    *   For 8-bit signed numbers, the range is typically **-128 to +127**.
    *   Still 256 possible values, just shifted. The MSB being 1 indicates a negative value (specifically, it contributes -128 to the total for an 8-bit number).

## Representing Fractional Numbers
*   How to store numbers like 3.14 or 0.001?
*   One common approach (related to floating-point representation) is similar to **scientific notation**.
*   Represent the number using two integers:
    *   One integer for the digits (the significand/mantissa, e.g., 314).
    *   Another integer for the exponent (indicating where the decimal point goes, e.g., -2).
    *   *Example:* Digits `314`, exponent `-2`. Start with `314.`, move point 2 places left -> `3.14`.
    *   *Example:* Digits `1234`, exponent `+4`. Start with `1234.`, move point 4 places right (add zeros) -> `12340000`.
*   This method allows representing both very small and very large numbers using a fixed number of bits for the significand and exponent.

## Memory as a String of Bytes
*   It's crucial to understand that at its most basic level, computer memory (RAM or storage) is just a long, linear sequence of bytes.
*   Think of it as a giant array of 8-bit numbers.
*   Programs and operating systems impose structure (variables, data types, files, folders), but the underlying hardware is just addressable bytes (Byte 0, Byte 1, Byte 2...).

## Representing Text - The Ascii Table
*   Need to represent letters and symbols using numbers (bytes).
*   **Ascii (American Standard Code for Information Interchange):** A standard mapping of byte values (0-127) to characters.
    *   Developed for early communication devices like **teleprinters** (electric typewriters connected over distance).
    *   Assignments were somewhat arbitrary but became standard because consistency was essential for communication.
    *   *Examples:* 'A' is 65, 'B' is 66, 'a' is 97, ' ' (space) is 32.
    *   **Control Codes:** Ascii values 0-31 are non-printable characters used for controlling devices (e.g., Bell (7), Line Feed (10), Carriage Return (13)).
    *   Line Feed (10) is still commonly used as the end-of-line marker in text files (especially on Unix/Linux).

## Code Pages
*   Ascii only used 7 bits (0-127). The 8th bit was often unused initially.
*   To represent characters for other languages (non-Latin alphabets) or additional symbols, the values 128-255 were used.
*   However, there was no single standard for this upper range. Different systems/regions created different **code pages** (extensions of Ascii).
*   *Example:* A code page for Cyrillic languages would map values 128-255 to Russian, Serbian, etc., letters. Other code pages existed for Greek, mathematical symbols, or even **box-drawing characters**.
*   **Box-drawing characters:** Used to create text-based graphical interfaces (like tables, boxes) in terminal applications. *Show example of old text-based interface or htop/btop.*
*   **Advice:** Code pages caused compatibility issues ("gibberish" text if the wrong code page was used). Modern systems use **Unicode** and **UTF-8** to handle a vast range of characters, avoiding the code page mess. Avoid code pages if possible.

## Files
*   Files are the primary way we organize data on long-term storage.
*   A file is essentially a **named chunk of bytes** on a storage device.
*   Files are organized hierarchically in folders/directories.
*   **Key Concept:** A file is *just* a sequence of bytes. Its meaning comes from how it's interpreted by software.
*   **Text Files:** Files intended to be interpreted as characters according to a character encoding (like ASCII or UTF-8). When opened in a text editor, they display meaningful text.
    *   *Example:* A `.txt` file, a `.csv` file, source code files (`.py`, `.c`, `.html`).
*   **Binary Files:** Files that are *not* intended to be interpreted directly as characters. Their bytes represent other types of data (images, sounds, executable instructions). When opened in a text editor, they appear as gibberish.
    *   *Example:* `.jpg`, `.mp3`, `.exe`, `.pdf` (PDFs are mixed, often start with text). *Show screenshot of opening an EXE or JPG in Notepad.*
*   **How a Text Editor (like Notepad) Works:**
    *   Reads the file byte by byte.
    *   For each byte, it looks up the corresponding character in its assumed character encoding (often Ascii or a code page initially, now usually UTF-8).
    *   Displays that character on the screen.
    *   Handles control codes (like Line Feed) by performing actions (moving cursor to next line).
    *   If the byte sequence wasn't meant to be text, the resulting characters look random or like symbols from the code page.

## Binary and Hexadecimal (Optional Deep Dive)
*   **Positional Number Systems:** Systems where a digit's value depends on its position (e.g., in 345, the '3' is 300, the '4' is 40, the '5' is 5).
*   **Base (or Radix):** The number of unique digits used in the system.
    *   Decimal (Base 10): 0-9
    *   Binary (Base 2): 0-1
    *   Octal (Base 8): 0-7
    *   Hexadecimal (Base 16): 0-9, A, B, C, D, E, F (A=10, F=15)
*   **Notation/Prefixes:** To avoid confusion, especially in programming, we use prefixes to indicate the base:
    *   Binary: `0b` (e.g., `0b101`)
    *   Octal: `0o` (e.g., `0o17`)
    *   Decimal: (No prefix, default) (e.g., `19`)
    *   Hexadecimal: `0x` (e.g., `0x1F`)
*   **Conversion (Hexadecimal to Decimal):**
    *   Use powers of the base (16).
    *   *Example:* `0x2F`
        *   Positions (from right, starting at 0): 1, 0
        *   Powers of 16: 16^1=16, 16^0=1
        *   Digits: 2, F
        *   Calculation: (2 * 16^1) + (15 * 16^0) = (2 * 16) + (15 * 1) = 32 + 15 = **47** (decimal).

*   **Important Advice on Pronunciation:** Avoid saying "ten in binary" or "fifteen in hex". This is confusing because "ten" and "fifteen" are common words with specific intuitive meaning. Instead, spell out the digits: "binary one zero" (which equals decimal two) or "hex one F" (which equals decimal twenty one). *Use the analogy of pilots spelling out numbers on the radio.*

## Historical Context: Displays
*   Early computers (1960s, like the IBM 360) didn't primarily use screens. Output was often on paper (like a printer).
*   Input was via keyboard, punched cards, or magnetic tape.
*   When screens were introduced, they initially served as replacements for printers. They received the same data streams, including control codes like Line Feed. Text would scroll up.
*   Early screens were often limited in resolution (e.g., 25 lines of 80 characters).
*   **Text Mode:** Displaying the screen content as a grid of characters (where each character is stored as a byte value referencing a font/glyph) was extremely memory efficient compared to storing every pixel.
    *   *Example:* Apple II computer (early personal computer) had very limited memory. A text screen (40x24 characters, ~1000 bytes) was feasible, while a graphical screen (640x480 pixels, ~38KB) was not practical with the available memory.
*   Text mode interfaces remained popular for a long time (e.g., Norton Commander in the 90s) and still exist in modern systems (e.g., htop, btop in Linux terminals) due to efficiency and usability for certain tasks.

## Conclusion
*   We covered how bits and bytes represent numbers and text.
*   Explored the history of data representation standards (Ascii, code pages).
*   Understood files as structured sequences of bytes and the difference between text and binary files.
*   Briefly touched on other number systems (hexadecimal) and historical display technologies.
*   The core idea is that everything in a computer is ultimately stored as bits, and humans/software impose meaning and structure on those bits.

## Recommended Resources
Point students to the optional videos, especially recommend the playlist on binary numbers and the 1964 IBM video for historical context. (see slides for links)

## Week 3
## Lecture 3 - Structure of Text

**Topic:** Understanding the structure of text, from historical perspectives to modern digital formats and the tools used to work with them.

**Why Talk About Text Structure?**
*   It often feels intuitive, but understanding the terminology and concepts is crucial for software development.
*   Many modern tools and data formats rely heavily on defined text structures, especially markup languages.

**Historical Examples of Text Structure**
*   **Ancient Legal Text (c. 1500s print of Justinian's work):**
    *   Printed in Venice (a printing capital at the time).
    *   Original text written ~1000 years prior by Emperor Justinian (Byzantine Empire), considered a forefather of modern legal systems. Written in Latin.
    *   Structure: Very visual, 2-dimensional. Large central text (the author's work) surrounded by commentary in smaller fonts. Common in religious publications where original text is old and requires interpretation. Designed for the human eye.
    *   *Note:* Latin was a common language for science and religion across Europe even when no longer a native language, enabling wider distribution before widespread translation was feasible.
*   **Ledger (George Washington Estate, 1700s):**
    *   Looks like a clear table structure.
    *   Obvious rows and columns for organizing data (e.g., quantity, price, item description).
*   **Newspaper (Omaha World Herald, 1961):**
    *   Very visual, 2-dimensional layout.
    *   Large titles, smaller body text, images. Designed for quick scanning by readers.

**Modern Text Structure Basics**
*   **Lines:** The most fundamental structural element in computer text files.
    *   Line breaks are represented by special control characters (e.g., ASCII code 10, the newline character). This character tells the computer/display to move to the next line.
    *   In programming and text editors, lines are often numbered, making it easy to refer to specific locations (e.g., "error on line 275").
*   **Whitespace:** Spaces, tabs, and newlines. Crucial for human readability.
*   **Indentation:** Whitespace at the beginning of a line or block of text.
    *   Used to visually group related lines and show hierarchical structure (e.g., in code, data formats like JSON).
    *   Makes text much easier for humans to parse visually, even if the computer ignores it.
*   **Paragraphs:** Important in traditional writing/publishing. Less emphasized in some technical text formats.

**Non-alphanumeric Characters**
*   Characters that are not letters (a-z, A-Z) or numbers (0-9).
    *   **Alphanumeric:** Letters and numbers.
    *   **Alpha:** Letters only.
    *   **Non-alphanumeric (or non-alpha):** All other printable characters.
*   **Common Examples and Names (useful to know for searching/discussing):**
    *   `.` - Period, full stop, decimal point.
    *   `-` - Hyphen, minus sign. (Note: Publishing has many dash types, ASCII usually only one short one).
    *   `()` - Parentheses, round brackets.
    *   `[]` - Square brackets.
    *   `{}` - Curly braces, curly brackets.
    *   `<>` - Angled brackets, less than/greater than signs. (Dual meaning: math comparison vs. HTML tags).
    *   `+` - Plus sign.
    *   `*` - Star, asterisk.
    *   `/` - Slash, forward slash, division symbol.
    *   `%` - Percent sign.
    *   `#` - Hash mark, pound sign, number sign.
    *   `$` - Dollar sign.
    *   `&` - Ampersand, 'and' sign.
    *   `@` - At sign.
    *   `\` - Backslash.
    *   `_` - Underscore, low dash. (Often treated like a letter in programming variable names).
    *   `^` - Caret, hat. (Often used for exponentiation).
    *   `~` - Tilde, tilda. (Used for approximation, or in some languages over letters like 'ñ').
    *   `` ` `` - Back tick, back quote.
    *   `|` - Vertical line, pipe. (Named after the Unix/Linux pipe operation).
*   **Finding on Keyboards:** Can vary significantly by keyboard layout (e.g., US vs. European layouts). Knowing the name helps in searching for how to type it.

**Markup Languages**
*   **Origin:** Concept comes from publishing workflows where editors would "mark up" manuscripts with symbols (often in red) to instruct typesetters (e.g., 'bf' for bold font, 'cap' for capitalize). This was the "proofreading markup language."

*   **Computer Adaptation:** Since we can't draw symbols on digital text, we embed instructions *within* the text stream using special characters or sequences. These instructions define how the text should be displayed or add semantic meaning.
*   **Examples:**
    *   **Markdown:** A simple, lightweight markup language.
        *   Designed for easy reading and writing in plain text.
        *   Syntax examples:
            *   Headings: `# Heading 1`, `## Heading 2`, etc.
            *   Bold: `**bold text**`
            *   Italic: `*italic text*`
            *   Lists: `* Bullet item`, `1. Numbered item` (the renderer handles the numbering sequence). Indentation creates nested lists.
        *   **Rendering:** The process of converting the raw markup text into a formatted visual output (e.g., HTML, PDF).
        *   Benefits: Very readable source, easy to write, good for simple documentation (like software READMEs). Popular in the last decade.
    *   **HTML (HyperText Markup Language):** The most common markup language, used for web pages.
        *   Hypertext: Text with links, images, and other non-linear elements.
        *   Structure: Uses tags enclosed in angle brackets (`<tag>`). Tags usually come in pairs: an opening tag (`<tag>`) and a closing tag (`</tag>`). Content is between the tags.
        *   Examples: 
            * `<p>A paragraph.</p>`
            `<strong>Bold text.</strong>`
            `<h1>Main heading.</h1>`
        *   History: HTML was proposed by Tim Berners-Lee while working at CERN (European Organization for Nuclear Research) in Switzerland. He was also involved with the W3C (World Wide Web Consortium), which develops web standards.
    
    *   **XML (eXtensible Markup Language):** Inspired by HTML, but designed more for structuring data than specifying display.
        *   Structure: Similar tag-based syntax 
        *   Focus: Describing the meaning and hierarchy of data elements.
        *   Popularity: Very popular in the 2000s, still used, but often replaced by JSON for many applications.
    *   **YAML** Increasingly popular for configuration files, known for its human-readable indentation-based structure.
    *   **Wiki Text:** Markup language used for editing pages on Wikipedia.

**Structured Data**
*   Data that has a defined, consistent organization, often resembling tables (rows as items, columns as properties) or hierarchical structures.
*   The definition is relative; some data is *more* structured than others.
*   Common text formats for representing structured data include XML and JSON.
*   **JSON (JavaScript Object Notation):** A lightweight format for data interchange.
    *   Structure: Based on key-value pairs (`"key": value`), objects (collections of key-value pairs, `{}`), and arrays (ordered lists of values, `[]`).
    *   Example (similar to the ledger/table data):
        ```json
        [
          {
            "description": "Item A",
            "units": 10,
            "unit_cost": 1.25
          },
          {
            "description": "Item B",
            "units": 5,
            "unit_cost": 3.00
          }
        ]
        ```
*   **Serialization:** The process of converting a data structure (like an object in memory) into a format (like a text string or byte sequence) that can be stored or transmitted, and then reconstructed later. JSON and XML are common text serialization formats.
*   **Human Readable Formats:** Text formats like JSON and XML are designed so humans can read and understand them (unlike binary formats or barcodes). This is a trade-off; they are often larger and slower for computers to process than binary formats, but much easier for developers to work with directly. Modern computing power often makes this trade-off acceptable.

**Browsers and Rendering Engines**
*   Browsers are some of the most complex projects on the planet. They fetch web resources (HTML, CSS, JavaScript, images), parse the text-based formats, and render the final visual page.
*   Building a browser from scratch is a massive undertaking requiring large teams and years of work.
*   **Rendering Engines:** The core component of a browser responsible for parsing HTML/CSS and laying out the page.
    *   There are only a few dominant rendering engines today (used by Chrome, Edge, Brave, Safari, Firefox). Many browsers share the same underlying engine.
*   **Web Standards:** Developed through collaboration (e.g., W3C) involving people from competing browser companies. This aims for consistency, though variations between browser versions and engines still exist, affecting web developers. (Historically, Internet Explorer was less compliant, creating difficulties).
*   Developers often use multiple browsers for testing compatibility.

**Special Characters and Escaping**
*   **Special Characters:** Characters that have a specific meaning or function within a particular language or context (e.g., `#` in Markdown headings, `<` in HTML tags, `"` when used to define a string in code).
*   **Escaping:** The mechanism used to tell the interpreter/renderer that a special character should be treated as a literal character, not with its special meaning.
*   **Escape Character:** A character that signals the following character should be escaped. The backslash `\` is commonly used.
*   **Escape Sequence:** The escape character followed by the character (or code) being escaped.
*   **Examples:**
    *   **Markdown:** To display a literal `#` at the start of a line: `\# Heading`. To display a literal backslash: `\\`.
    *   **Code (Strings):** In many languages (Python, JavaScript), to include a quote character within a string defined by the *same* quote character:
        ```python
        print("He said, \"Hello!\"") # Escape double quote in double-quoted string
        print('It\'s a good day.') # Escape single quote in single-quoted string
        ```
    *   **HTML:** Uses character references starting with `&` and ending with `;`.
        *   To display a literal `<`: `&lt;` (`lt` for less than).
        *   To display a literal `>`: `&gt;` (`gt` for greater than).
        *   To display a literal `&`: `&amp;` (`amp` for ampersand).
        *   Documentation: MDN (Mozilla Developer Network) and W3C provide comprehensive references.

**Lab Exercise Connection**
*   The lab involves editing Markdown documents.
*   This will be done using Github.
*   **Github:** A web platform primarily for hosting software code repositories, but also widely used for managing text documents.
    *   Organized into **repositories** (like project folders).
    *   Often contains a `README.md` file (written in Markdown) displayed prominently.
    *   Provides a web editor for files, including a Markdown preview.
    *   Saving changes is called **committing**.
    *   Useful tool for collaboration and version control, even for non-code text (e.g., German government legislation hosted on Github).
    *   Recommended to create a Github account (consider using a personal email and adding college email for potential student benefits).

**Resources Mentioned:**
*   Videos: "Github for Poets" playlist (recommended for Git/Github intro).
*   Documentation: MDN (Mozilla Developer Network), W3C (World Wide Web Consortium).

## Week 4

## Lecture 4: Manipulating Text & Text Editors

## Introduction & Recap
*   Brief recap of Lecture 3:
    *   History and structure of written text and numbers.
    *   Representing text/numbers using bits, bytes, and ASCII.
    *   Markup languages, specifically Markdown and HTML.
*   Today's focus: Working with text, manipulating it – your tools of the trade.
*   Reference the image of the scribe (Luke the Evangelist, ~1000 AD Constantinople):
    *   Discuss the tools shown (desk, footrest - still relevant concept of comfortable setup).
    *   Emphasize the importance of a comfortable workspace setup (desk, chair, monitor arrangement) to avoid strain and pain from prolonged computer use. It's crucial for long-term health and productivity.

## Agenda

*   Keyboards (basic but essential)
*   Text Editors - one of the most important tools for developers
    *   History (Vi/Emacs)
    *   Introduction to VS Code (most popular nowadays)
*   Searching in Text (Ctrl+F and beyond)
*   Brief Lab Preview - Github Pages

## Keyboards

*   **Importance:** Keyboards and mice are our primary interface to convey thoughts/intentions to the computer. Mastering the keyboard is key.
*   **History:** Word comes from musical instruments. Early typing keyboards looked like piano keys but quickly evolved to the modern layout for mechanical/convenience reasons. The IBM Model M (1985) set a standard for the modern keyboard layout that persists today.
*   **Types & Comfort:**
    *   Show examples of different physical layouts (split, vertical, ortholinear) to illustrate variety.
    *   Reiterate the importance of comfort and ergonomics. Listen to your body; adjust your setup (chair height, desk height, keyboard position) if you feel discomfort or strain. Repetitive Strain Injury (RSI) is a serious risk.
*   **Layouts:**
    *   Distinguish between:
        *   Physical Layout: Key arrangement and shape.
        *   Visual Labeling: What's printed on the keys.
        *   Functional/Software Layout: What characters are produced (can be changed in OS settings, e.g., switching languages).
    *   Common Layouts:
        *   **QWERTY:** Most common globally (historical reasons, standardization). Difficult to switch once learned.
        *   Mention regional variants like QWERTZ (German - Z/Y swap, different punctuation placement) or AZERTY (French). Note the annoyance of different punctuation layouts when switching languages.
        *   Alternative Layouts: Dvorak, Colemak (designed for efficiency, common letters/combinations under strong fingers). Note they are not popular; the benefit in speed is often outweighed by the inconvenience of non-standard layouts. Anything non-standard becomes a problem when using shared computers.
    *   Mention specialized keyboards like those used by stenographers (chord-based entry for speed).
*   **Modifier Keys:** Keys like `Ctrl`, `Shift`, `Alt`, `Windows`/`Command`. They have no function alone but modify other keys (`Shift+A` -> `A`, `Ctrl+C` -> Copy). Mention historical examples (Meta, Super, Hyper). Note icons used in documentation (e.g., Mac Command icon).

*   **Shortcuts:**
    *   Strongly recommend using common shortcuts (`Ctrl+C`, `Ctrl+V`, `Ctrl+Z`).
    *   The main benefit is **reduced cognitive load**, not just speed. Automatism frees up brainpower for more complex thinking.
    *   Customizing shortcuts: Can be useful but often creates inconvenience when using other computers/systems. Sticking to defaults is often better unless there are conflicts between applications (e.g., Photoshop vs. VS Code).

*   **How Keys Work (Hardware Basics):**
    *   **Rubber Dome:** Most common technology. Rubber sheet with domes that collapse when pressed, connecting a circuit. (Like a pop-it toy).
    *   **Mechanical Switches:** Older, used in modern enthusiast keyboards. Involve springs and physical mechanisms. Provide tactile and/or auditory feedback ("clicky"). Different types often named by color (Blue - clicky/loud, Brown - tactile bump/quieter, Red - linear/smooth). Personal preference varies greatly.
    *   No single "best" keyboard. Use what feels comfortable but bee attentive when a keyboard annoys you - this might be a signal to change something.

*   **Key Events:**
    *   Explain that the computer receives events for *both* key press (down) and key release (up).
    *   Show the `evtest` log example: Events include key code, label (e.g., `left control`), and value (1 for down, 0 for up). Timestamps allow measuring press duration.

*   **Programmable Keyboards:** Some keyboards allow programming key combinations. Pressing `Fn` + `A` might send a `Left Arrow` event to the computer, without the computer necessarily knowing the `Fn` key itself was pressed. Niche for enthusiasts.

*   **Touch Typing:**
    *   Typing without looking at the keys.
    *   Historical context: Became important with typewriters (fixing errors was hard). Competitions existed (e.g., Cincinnati 1880s winner using touch typing).
    *   Benefits: Faster speed, better precision, significantly reduced cognitive load and fatigue.
    *   Learning:
        *   Use online training programs (Ratatype, Keybr, Monkeytype, etc.).
        *   Focus on **precision first**, then speed. Type slowly and accurately initially.
        *   Practice regularly (15-20 minutes daily is much better than long sessions rarely).
        *   It's a mechanical skill requiring consistent exposure.
        *   r/typing subreddit is a great resource


## Text Editors

*   **Distinction:**
    *   **Word Processors** (e.g., Microsoft Word): Designed for rich text formatting (fonts, colors, layout). Convenient for documents intended for human reading/printing. **Very inconvenient for writing code** (auto-correct, hidden formatting).
    *   **Text Editors** (e.g., Notepad, Notepad++, VS Code, Vim): Designed for plain text. Each byte typically corresponds directly to a character via ASCII. Provide precise control over the raw text file. **Essential for writing code**.
    *  **Unicode** optionally, mention how in UTF-8 some characters are represented using multiple bytes

*   **IDEs (Integrated Development Environments):**
    *   Historically distinct, now blurring the line with advanced text editors.
    *   Combine a text editor with many other tools for software development (compilers, debuggers, build tools, version control integration, etc.).
    *   Often optimized for specific programming languages (e.g., WebStorm for web dev, PyCharm for Python, Visual Studio for C#/Microsoft stack).
    *   Mention early examples like Turbo C++ (text-mode IDE).

*   **History:**
    *   **Vi** (later **Vim**) and **Emacs**: Released around the same time (1976). Famous for sparking "religious wars" among developers.
    *   Still widely used today. Vim is often pre-installed on Unix-like systems (Linux, macOS), making it a common default terminal editor.
    *   Mention Vim's modal nature (insert mode for typing, command mode for actions).
    *   Show how to exit Vim: `Esc`, then `:q!`, then `Enter`.
    *   Mention resources like Vim Adventures (a game to learn Vim basics).

*   **VS Code (Visual Studio Code):**
    *   Developed by Microsoft, but is open source and free (distinct from the commercial Visual Studio IDE).
    *   Released relatively recently (2015) but has become the most popular text editor/lightweight IDE.
    *   According to Stack Overflow Developer Survey about 75% of respondents reported using it in some capacity (not always as their main editor). Note survey bias towards younger, more enthusiastic developers.
    *   Pros: Very popular (useful for collaboration, internships), feature-rich, large extension ecosystem.
    *   Cons: Can become resource-heavy especially if many extensions are installed.
    *   Recommendation: Use VS Code for this course unless another editor is specifically required or you have a strong preference for another. Using the same tool as the instructor/classmates simplifies asking for and receiving help.


## Searching in Text

*   **Basic Search:** `Ctrl+F` (or `Cmd+F` on Mac) is the fundamental shortcut. Use it everywhere (browsers, documents, editors).
*   **Search and Replace:** Often `Ctrl+H`. Useful for bulk changes (e.g., renaming variables).

*   **Editor Search Features:** Demonstrate common options in a text editor (VS Code):
    *   **Match Case:** Toggle case-sensitive search. Important in programming where `variable` and `Variable` can be different.
    *   **Match Whole Word:** Only find occurrences that are standalone words (surrounded by space, punctuation, or line breaks), not substrings within other words.

*   **Fuzzy Search / Patterns:** Introduce the need to search for patterns rather than exact strings when the target isn't precisely known.
*   **Wildcards:** Simple pattern matching, often used in file systems (`*.txt`, `?a?`). Explain `*` (any characters) and `?` (any single character). The term "wildcard" originated from card games where some card (usually the Joker) could be used in place of any other card. 

*   **Regex (Regular Expressions):**
    *   **Concept:** A powerful, complex language for describing text patterns. Can look like "line noise" (show the complex email regex example).
    *   **Goal for this class:** Awareness of its existence and capability. Fluency is not expected.
    *   **Basic Syntax Examples (Demonstrate in editor/regex tool):**
        *   Literal characters match themselves.
        *   Character Sets: `[abc]` (matches 'a', 'b', or 'c'), `[A-Z]` (matches any uppercase letter), `[0-9]` or `\d` (matches any digit).
        *   Quantifiers: `+` (one or more of the preceding element), `*` (zero or more), `{n,m}` (between n and m times).
        *   Show simple examples like searching for "line" followed by one or more digits (`line\d+`).
    *   **Tools:** Mention online regex testers/debuggers (Regex101, RegExr) that help build and explain regex patterns.
    *   **Practicality:** Useful in editors for advanced search/replace. ChatGPT is very good at generating regex patterns, then you can test them in a debugger like RegExr. Debugging complex regex is notoriously difficult.


## Lab Preview / Integrated Demo

*   **Github Pages:**
    *   It's a static site hosting service built into Github.
    *   Allows publishing a website directly from a repository, often rendering a Markdown file (like `README.md`) as a webpage.
    *   Show the transformation from a raw Markdown file to a formatted webpage hosted on a `github.io` URL.
    *   Screenshots in lab instructions show how to enable GitHub Pages for a repository.
    *   Note the typical ~1 minute delay for changes to appear after committing (can check progress in the "Actions" tab).
    *   Show how changing the `theme` setting in the `_config.yml` file dramatically changes the visual appearance of the page. Show committing this change and waiting for the update. Suggest exploring different themes.
*   **VS Code in Browser (`.dev` trick):**
    *   Show the neat trick: changing `github.com` in the URL to `github.dev` launches a web-based version of VS Code directly connected to that repository.
    *   Demonstrate the VS Code interface (File Explorer, Editor pane, Source Control tab).
    *   Show editing the Markdown `README.md` file.
    *   Show opening the Markdown preview side-by-side and demonstrating live updates as text is typed/changed.
*   **Editor Features (Demo):**
    *   **Multiple Cursors:** Show selecting a word and using `Ctrl+D` (or equivalent) to select subsequent occurrences. Demonstrate typing simultaneously at multiple cursor locations. Even if not always useful, it looks very impressive. 
*   **Versioning (Source Control Tab):**
    *   Show the Source Control tab (Git integration) in VS Code.
    *   Show how it lists modified files.
    *   Show the diff view, highlighting exactly what lines were added/changed/deleted.
    *   Demonstrate committing changes: entering a commit message explaining what and *why* was changed for history tracking and pushing to the Github repository.

## Resources

*   Recommend exploring the resources linked in the slides:
    *   Typing training sites (Ratatype, Keybr, Monkeytype, etc.)
    *   Typing subreddit and guide.
    *   Online Regex testers/debuggers (Regex101, RegExr).
    *   Vim learning resources (Vim Adventures game, articles).
    *   Fireship videos (short, fast-paced tech explanations).
    

## Week 5
## Lecture 5: Command Line Interfaces (CLI)

This lecture introduces students to the command-line interface, its history, fundamental concepts, and practical uses, particularly in software development and remote server interaction.

## Recap of Previous Weeks

*   Subjects covered in the previous weeks:
    *   History and structure of text/numbers before computers.
    *   Bits, bytes, ASCII encoding.
    *   Importance of mastering the keyboard (touch typing practice).
    *   Text editors (tool of the trade, ongoing learning/discussion).
    *   Searching (`Ctrl+F`), awareness of Regular Expressions (Regex).

## Introduction to Command Line Interfaces (CLI)

*   What is the "black terminal" or CLI?
*   It's an interface where you type commands and the computer responds with text.
*   Analogy: It's like talking to a Chatbot with a very specific and limited set of commands.

## History of CLIs

*   **Early Days:** CLI was the *only* way to interact with computers.
*   **Teletype Machines:** Connected printers and keyboards to computers.
    *   Operator typed a command.
    *   Command was printed on paper.
    *   Computer processed and printed the reply on paper.
    *   This was a direct command-reply dialogue.
    *   Commands were often shortened (2-3 letters) for efficiency, leading to cryptic command names today.

*   **TV Screens (Virtual Terminals):** As TVs became widespread, screens replaced paper printers.
    *   Huge saving on paper.
    *   More convenient (see what you type, easy correction).
    *   Mode of operation remained the same: type command, get text reply.
    *   Examples: VT100 terminal.
*   **Text-based Games:** Games like Zork demonstrated this interactive text-based dialogue format.

## Anatomy of a Modern CLI

*   **Prompt:** The text displayed before you type a command.
    *   Often contains useful info: username, computer name, current directory.
    *   Example: `user@hostname:~/current/directory$`
    *   `~` often represents the user's home directory.
    *   The symbol at the end (`$`, `#`, `>`) is just the end of the prompt.
*   **Command:** The instruction you type.
*   **Response/Output:** The text the computer prints after executing the command.
*   **Cursor:** Blinking indicator inviting the next command.

## Why Use the CLI? (Advantages)

*   **Functionality:** Some tools or features are *only* available via CLI (cheaper/easier to build CLI tools than GUI).
*   **Speed:** Much faster for certain types of work.
*   **Precise Control:** Allows specifying details down to the tiniest level.
*   **Automation:** Commands are lines of text. Can easily create scripts (text files of commands) to automate repetitive tasks.
*   **Remote Work (SSH):** Works extremely well over networks, even slow ones, due to low bandwidth requirements (sending text commands and receiving text replies).
*   **Low Resource Usage:** Doesn't require graphical rendering, less demanding on the computer and can therefore be used to control tiny devices.
*   **Looks Cool**

## SSH (Secure Shell)

*   Primary tool for connecting to remote computers over a network.
*   Replaced older, less secure methods.
*   **Secure:** Communication is encrypted for privacy.
*   **Shell:** Refers to the command-line environment you get on the remote machine.
*   Basic usage: `ssh username@server_address`
*   After connecting, you get a command prompt on the remote server, just like a local one.

## Lab Demonstration (Bandit Game)

*   Use the Bandit game (an information security wargame) as a practical CLI exercise.
*   Game is text-based on a remote server.
*   Goal: Find the password for the next level in each level.
*   Start with `bandit0`.
*   **Connecting:** `ssh bandit0@server_address`
*   Enter password (initially `bandit0` for level 0). Password typing is hidden (no stars/feedback).
*   Once connected, the prompt shows the current level (e.g., `bandit0@bandit:~$`).
*   **Basic Commands for Exploration:**
    *   `ls`: List files in the current directory.
        ```bash
        ls
        ```
    *   `ls -l`: Long listing format (shows permissions, owner, size, date/time).
        ```bash
        ls -l
        ```
    *   `ls -a`: List *all* files, including hidden ones (starting with `.`).
        ```bash
        ls -a
        ```
    *   `pwd`: Print Working Directory (show the full path of the current directory).
        ```bash
        pwd
        ```
    *   `cd directory_name`: Change directory to `directory_name`.
        ```bash
        cd /home/bandit1
        ```
    *   `cd ..`: Change directory to the parent directory.
        ```bash
        cd ..
        ```
    *   `cd ~` or `cd`: Change directory to the home directory.
        ```bash
        cd
        ```
*   **Getting Help:**
    *   `man command_name`: Display the manual page for a command (interactive, use `q` to exit).
        ```bash
        man ls
        ```
        *   Can search within `man` pages using `/` followed by the search term.
*   **Viewing File Contents:**
    *   `less filename`: View file content interactively (can scroll, search, use `q` to exit). Name is a historical joke (better than `more`).
        ```bash
        less readme
        ```
    *   `cat filename`: Concatenate (print) file content directly to the terminal and exit immediately. Good for short files or scripting.
        ```bash
        cat readme
        ```
*   **Tab Completion:** Emphasize using the `Tab` key to autocomplete commands and filenames. Saves typing, reduces errors.
*   **Copy/Paste:** Mention it can be finicky due to historical reasons (`Ctrl+C` often being the keyboard interrupt). On Windows terminals, selecting text often copies, and right-click often pastes. Mac/Linux terminals might use `Cmd+C`/`Cmd+V` or `Ctrl+Shift+C`/`Ctrl+Shift+V` depending on configuration.

*   **Solving Level 0:** Use `cat readme` to display the password. Copy the password.
*   **Exiting:** Use `exit` to disconnect from the SSH session.
*   **Connecting to Level 1:** Change the username in the SSH command: `ssh bandit1@server_address`. Paste the password obtained from Level 0.
*   **Solving Level 1:** Challenge is a file named `-`. `ls` shows `-`. `cat -` won't work directly (dash is interpreted as an option). Solution: `cat ./-` (`./` specifies the current directory, making the file name explicit).

## Starting the Terminal on Your Computer

*   How to open the black window:
    *   **Mac OS:**
        *   Spotlight Search (`Cmd + Space`) -> Type "Terminal" -> Enter.
        *   Applications -> Utilities -> Terminal.
    *   **Windows:**
        *   Start Menu -> Search bar -> Type "Terminal", "Cmd" or "Powershell".
    *   Mention **Putty** as a third-party alternative, especially for older Windows versions or if built-in options are problematic. It's a simple SSH client.


## Windows Subsystem for Linux (WSL)

*   Allows running a Linux environment (like Ubuntu) directly within Windows.
*   **Benefit:** Get the advantages of Linux command-line tools and development environments while still using Windows GUI applications.
*   Often preferred for certain types of development (e.g., web development with Node.js, Ruby, Python) where tools are primarily optimized for Linux/Mac OS.
*   Easy installation: Available from the Microsoft Store (search for "Ubuntu" and choose the latest LTS version like 24.04 LTS).
*   Can integrate with tools like VS Code (VS Code runs on Windows, but can operate on files and run commands within the WSL environment).

## CLI Command Structure

*   General format: `command [subcommand] [options/flags] [arguments]`
*   **Command:** The main program name (e.g., `ls`, `cat`, `cd`).
*   **Subcommand:** Some complex tools have subcommands (e.g., `git add`, `git commit`).
*   **Options/Flags:** Modify command behavior. Start with `-` (short form, e.g., `-l`, `-a`) or `--` (long form, e.g., `--long`, `--all`). Can often combine short options (`ls -la`).
*   **Arguments:** The inputs the command operates on (e.g., filenames, directory names). `cat readme` (`readme` is the argument).

## More Useful Basic Commands

*   `cp source destination`: Copy files or directories.
*   `mv source destination`: Move (rename) files or directories.
*   `mkdir directory_name`: Make (create) a new directory.
*   `ping hostname_or_ip`: Send network packets to a host to test connectivity and measure latency.
    ```bash
    ping google.com
    ```
    *   Use `Ctrl+C` to stop `ping`.

## `grep` Command

*   A powerful tool for searching plain-text data.
*   Searches for lines matching a specified pattern (often a regular expression).
*   Basic usage: `grep pattern filename` (find lines containing `pattern` in `filename`).
    ```bash
    grep build tst.json
    ```
*   Can search recursively through directories (`grep -r pattern directory/`).

## Input/Output Redirection and Piping

*   **Standard Output (stdout):** Where a command usually sends its output (by default, the terminal).
*   **Standard Input (stdin):** Where a command usually receives its input (by default, the keyboard).
*   **Redirection (`>` and `>>`):** Change where standard output goes.
    *   `command > file`: Redirect output to a file, *overwriting* the file if it exists.
        ```bash
        ls -l > listing.txt
        ```
    *   `command >> file`: Redirect output to a file, *appending* to the file if it exists. Useful for logs.
*   **Piping (`|`):** Connect the standard output of one command to the standard input of another command.
    *   `command1 | command2`: Output of `command1` becomes input for `command2`.
    *   Example: Use `wc -l` (word count, `-l` counts lines) to count the output lines of `ls -l`.
        ```bash
        ls -l | wc -l
        ```
*   **Fun Examples with Pipes:**
    *   `cowsay message`: A command that prints a cow saying `message`.
    *   `lolcat`: A command that adds rainbow colors to text input.
    *   Combine them: `ls -l | wc -l | cowsay | lolcat` (Pipe the line count to cowsay, then pipe cowsay's output to lolcat for color). Requires installing these utilities (often easier on Linux/Mac).

## Unix Philosophy

*   A design philosophy originating from the Unix operating system.
*   Core idea: Build small, simple, specialized programs that do one thing well, and provide mechanisms (like pipes and redirection) to connect them together to perform complex tasks.
*   Contrast: Building large, monolithic programs that try to do everything.
*   Benefit: Easier to develop, test, and maintain small tools. Analogy to modern "microservices" architecture.
*   Caveat: it's not always possible, sometimes the subsystems are tightly coupled and you can't really avoid building a large monolith.

## Other Network/CLI Tools

*   **scp (Secure Copy):** Copy files over an SSH connection.
    ```bash
    scp local_file user@server:remote_path
    ```
*   **ftp / sftp (File Transfer Protocol / Secure FTP):** Protocols for transferring files. Sftp is the secure, encrypted version.
    *   Often used with GUI clients like **Filezilla**  - a GUI application for file transfer between local and remote servers.

## Text-based User Interfaces

*   Interactive applications that run within the terminal but provide a more structured interface than just a command prompt.
*   Use text characters to draw windows, menus, graphs, etc.
*   Example: `htop` or `btop` (system monitors showing CPU, memory, processes).
    *   Useful for monitoring remote servers via SSH.
    *   Interactive (can navigate, sort, kill processes).
    *   Exit typically with `q`.

## `tmux` (Terminal Multiplexer)

*   A tool to manage multiple terminal sessions within a single window or SSH connection.
*   Key benefits:
    *   **Session Persistence:** Keep processes running on a remote server even if your local connection drops or you disconnect.
    *   **Window/Pane Management:** Split the terminal window into multiple panes, run different commands in each.
*   Useful for complex remote work or running background processes.

## Recommended Resources

*   Command Line Crash Course video (available on D2L).
*   Articles on `tmux` and `htop` for advanced use

## Conclusion

*   The command line, while seemingly archaic, remains a powerful and essential tool for developers, system administrators, and anyone working extensively with computers, especially remotely.
*   Basic navigation, file manipulation, and understanding redirection/piping unlocks significant capabilities.

